import React, { useState, useRef, useCallback } from 'react';
import { Button, Card, Space, Modal, Typography, Row, Col, message, Tabs, Tooltip, Result, Input, Form, Tree } from 'antd';
import { 
  EditOutlined, 
  SaveOutlined, 
  DownloadOutlined, 
  EyeOutlined, 
  FileTextOutlined,
  CodeOutlined,
  BulbOutlined,
  CopyOutlined,
  Html5Outlined,
  ExportOutlined,
  BookOutlined, // For Obsidian
  FolderOpenOutlined // For folder selection
} from '@ant-design/icons';
import ReactQuill from 'react-quill';
import 'react-quill/dist/quill.snow.css';
import html2canvas from 'html2canvas';
import jsPDF from 'jspdf';
import { getHtmlStyle } from '../utils/htmlStyles';

const { Title, Text } = Typography;
const { TabPane } = Tabs;

const EditableOutput = ({ generatedArticle, onSave, selectedHtmlStyle = 'modern' }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editedContent, setEditedContent] = useState('');
  const [isHtmlPreviewVisible, setIsHtmlPreviewVisible] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
  const [isObsidianModalVisible, setIsObsidianModalVisible] = useState(false);
  const [isFolderSelectorVisible, setIsFolderSelectorVisible] = useState(false);
  const [obsidianDirectories, setObsidianDirectories] = useState([]);
  const [selectedFolder, setSelectedFolder] = useState("Generated Articles");
  const [obsidianForm] = Form.useForm();
  const previewRef = useRef(null);

  const generateHtmlTemplate = useCallback((content, style) => {
    if (!generatedArticle) return '';
    
    const styleConfig = getHtmlStyle(style);
    
    return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${generatedArticle.title}</title>
    <style>
        ${styleConfig.css}
        
        @media (max-width: 768px) {
            .container {
                margin: 0;
                box-shadow: none;
            }
            
            .header, .content {
                padding: 32px 24px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .content {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>${generatedArticle.title}</h1>
            <div class="subtitle">Generated by AI Content Weaver</div>
        </div>
        <div class="content">
            ${content}
        </div>
        <div class="footer">
            <p>Created with AI Content Weaver • ${new Date().toLocaleDateString()}</p>
        </div>
    </div>
</body>
</html>`;
  }, []);

  const handleEdit = () => {
    setEditedContent(generatedArticle.preview_html);
    setIsEditing(true);
  };

  const handleSave = () => {
    if (onSave) {
      onSave(editedContent);
    }
    setIsEditing(false);
    message.success('Content saved successfully!');
  };

  const handleCancel = () => {
    setIsEditing(false);
    setEditedContent('');
  };

  const handleCopyMarkdown = () => {
    if (generatedArticle && generatedArticle.article_markdown) {
      navigator.clipboard.writeText(generatedArticle.article_markdown)
        .then(() => message.success("Markdown content copied to clipboard!"))
        .catch(err => {
          message.error("Failed to copy Markdown content.");
          console.error('Failed to copy text: ', err);
        });
    }
  };

  // Generate filename with timestamp
  const generateFileName = (extension) => {
    const now = new Date();
    const timestamp = now.getFullYear() +
      String(now.getMonth() + 1).padStart(2, '0') +
      String(now.getDate()).padStart(2, '0') + '_' +
      String(now.getHours()).padStart(2, '0') +
      String(now.getMinutes()).padStart(2, '0') +
      String(now.getSeconds()).padStart(2, '0');
    return `weaved_${timestamp}.${extension}`;
  };

  const exportToHtml = useCallback(() => {
    const content = isEditing ? editedContent : generatedArticle.preview_html;
    const htmlContent = generateHtmlTemplate(content, selectedHtmlStyle);

    const blob = new Blob([htmlContent], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = generateFileName('html');
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    message.success('HTML file downloaded successfully!');
  }, [generatedArticle, isEditing, editedContent, selectedHtmlStyle, generateHtmlTemplate]);

  const exportToPdf = useCallback(async () => {
    if (!previewRef.current) return;
    
    setIsExporting(true);
    try {
      const canvas = await html2canvas(previewRef.current, {
        scale: 2,
        useCORS: true,
        allowTaint: true,
        backgroundColor: '#ffffff'
      });
      
      const imgData = canvas.toDataURL('image/png');
      const pdf = new jsPDF({
        orientation: 'portrait',
        unit: 'mm',
        format: 'a4'
      });
      
      const imgWidth = 210;
      const pageHeight = 295;
      const imgHeight = (canvas.height * imgWidth) / canvas.width;
      let heightLeft = imgHeight;
      
      let position = 0;
      
      pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
      heightLeft -= pageHeight;
      
      while (heightLeft >= 0) {
        position = heightLeft - imgHeight;
        pdf.addPage();
        pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
        heightLeft -= pageHeight;
      }
      
      pdf.save(generateFileName('pdf'));
      message.success('PDF exported successfully!');
    } catch (error) {
      message.error('Failed to export PDF: ' + error.message);
    } finally {
      setIsExporting(false);
    }
  }, [generatedArticle]);

  const handleSaveToObsidian = async (values) => {
    if (!generatedArticle || !generatedArticle.article_markdown) {
      message.error("No content to save.");
      return;
    }

    try {
      const response = await fetch("/api/v1/obsidian/save", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          vault_path: values.vault_path,
          folder_name: values.folder_name,
          file_name: values.file_name,
          content: generatedArticle.article_markdown,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.detail || "Failed to save to Obsidian");
      }

      message.success("Successfully saved to Obsidian!");
      setIsObsidianModalVisible(false);
      obsidianForm.resetFields();
    } catch (error) {
      message.error(error.message);
    }
  };

  const handleOpenFolderSelector = async () => {
    try {
      const vaultPath = await obsidianForm.getFieldValue('vault_path');
      if (!vaultPath) {
        message.error("Please provide the Obsidian vault path first.");
        return;
      }

      const response = await fetch("/api/v1/obsidian/directories", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ vault_path: vaultPath }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.detail || "Failed to fetch directories");
      }

      const data = await response.json();
      setObsidianDirectories(data.directories);
      setIsFolderSelectorVisible(true);
    } catch (error) {
      message.error(`Error fetching directories: ${error.message}`);
    }
  };

  const handleSelectFolder = (selectedKeys) => {
    if (selectedKeys.length > 0) {
      setSelectedFolder(selectedKeys[0]);
      obsidianForm.setFieldsValue({ folder_name: selectedKeys[0] });
      setIsFolderSelectorVisible(false);
    }
  };

  const quillModules = {
    toolbar: [
      [{ 'header': [1, 2, 3, false] }],
      ['bold', 'italic', 'underline', 'strike'],
      [{ 'list': 'ordered'}, { 'list': 'bullet' }],
      [{ 'indent': '-1'}, { 'indent': '+1' }],
      ['blockquote'],
      ['link'],
      [{ 'align': [] }],
      ['clean']
    ],
  };

  const quillFormats = [
    'header', 'bold', 'italic', 'underline', 'strike',
    'list', 'bullet', 'indent', 'blockquote', 'link', 'align'
  ];

  if (generatedArticle.status === "error") {
    return (
      <Result
        status="error"
        title={generatedArticle.title}
        subTitle={generatedArticle.subTitle}
        style={{
          background: '#fff',
          borderRadius: 16,
          padding: '48px 24px',
          boxShadow: '0 12px 28px rgba(0,0,0,0.06)'
        }}
      />
    );
  }

  return (
    <>
      <Card 
        title={
          <Row justify="space-between" align="middle">
            <Col>
              <Title level={4} style={{marginBottom: 0, fontWeight: 600}}>
                Generated Article: <Text style={{fontWeight: 400, color: 'rgba(0,0,0,0.6)'}}>{generatedArticle.title}</Text>
              </Title>
            </Col>
            <Col>
              <Space>
                <Tooltip title="Edit Content">
                  <Button
                    icon={<EditOutlined />}
                    onClick={handleEdit}
                    disabled={isEditing}
                    shape="round"
                  >
                    Edit
                  </Button>
                </Tooltip>
                <Tooltip title="Export as HTML">
                  <Button
                    icon={<Html5Outlined />}
                    onClick={exportToHtml}
                    shape="round"
                  >
                    HTML
                  </Button>
                </Tooltip>
                <Tooltip title="Export as PDF">
                  <Button
                    icon={<DownloadOutlined />}
                    onClick={exportToPdf}
                    loading={isExporting}
                    shape="round"
                  >
                    PDF
                  </Button>
                </Tooltip>
                <Tooltip title="Preview HTML">
                  <Button
                    icon={<EyeOutlined />}
                    onClick={() => setIsHtmlPreviewVisible(true)}
                    shape="round"
                  >
                    Preview
                  </Button>
                </Tooltip>
                <Tooltip title="Save to Obsidian">
                  <Button
                    icon={<BookOutlined />}
                    onClick={() => setIsObsidianModalVisible(true)}
                    shape="round"
                  >
                    Obsidian
                  </Button>
                </Tooltip>
              </Space>
            </Col>
          </Row>
        }
        variant="filled"
        style={{ borderRadius: 16, boxShadow: '0 12px 28px rgba(0,0,0,0.06)', marginTop: 24 }}
      >
        {isEditing ? (
          <div style={{ marginBottom: 16 }}>
            <ReactQuill
              value={editedContent}
              onChange={setEditedContent}
              modules={quillModules}
              formats={quillFormats}
              style={{ minHeight: 300 }}
              theme="snow"
            />
            <Row justify="end" style={{ marginTop: 16 }}>
              <Space>
                <Button onClick={handleCancel}>Cancel</Button>
                <Button type="primary" icon={<SaveOutlined />} onClick={handleSave}>
                  Save Changes
                </Button>
              </Space>
            </Row>
          </div>
        ) : (
          <Tabs defaultActiveKey="1" centered type="card" tabBarGutter={8}>
            <TabPane tab={<Space><FileTextOutlined/>Preview</Space>} key="1">
              <div 
                ref={previewRef}
                className="html-preview-box"
                dangerouslySetInnerHTML={{ __html: generatedArticle.preview_html }} 
                style={{
                  padding: '24px',
                  border: '1px solid rgba(0,0,0,0.08)',
                  borderRadius: 12,
                  background: '#f8f8f9',
                  height: 'calc(100vh - 500px)',
                  lineHeight: 1.6,
                  // CSS 隔离样式，防止生成内容影响网页其他部分
                  contain: 'layout style paint',
                  isolation: 'isolate',
                  overflow: 'auto',
                  overflowWrap: 'break-word',
                  wordBreak: 'break-word',
                  // 重置可能被生成内容影响的样式
                  fontFamily: 'inherit',
                  fontSize: 'inherit',
                  color: 'inherit',
                  // 限制子元素可能的样式溢出
                  position: 'relative',
                  zIndex: 1
                }}
              />
            </TabPane>
            <TabPane tab={<Space><CodeOutlined/>Markdown</Space>} key="2">
              <div style={{padding: '16px', background: '#2d2d2d', borderRadius: 12, height: 'calc(100vh - 500px)', overflow: 'auto'}}>
                <Row justify="end" style={{ marginBottom: 8 }}>
                  <Col>
                    <Button
                      icon={<CopyOutlined />}
                      onClick={handleCopyMarkdown}
                      size="small"
                    >
                      Copy Markdown
                    </Button>
                  </Col>
                </Row>
                <pre style={{ margin: 0, color: '#f0f0f0', whiteSpace: 'pre-wrap', wordBreak: 'break-all' }}>
                  <code>{generatedArticle.article_markdown}</code>
                </pre>
              </div>
            </TabPane>
            {generatedArticle.suggestions && generatedArticle.suggestions.length > 0 && (
              <TabPane tab={<Space><BulbOutlined/>Suggestions</Space>} key="3">
                <div style={{ height: 'calc(100vh - 500px)', overflow: 'auto', padding: '16px' }}>
                  <ul style={{ paddingLeft: 20, lineHeight: 1.8 }}>
                    {generatedArticle.suggestions.map((s, i) => <li key={i}><Text>{s}</Text></li>)}
                  </ul>
                </div>
              </TabPane>
            )}
          </Tabs>
        )}
      </Card>

      <Modal
        title={
          <Space>
            <Html5Outlined style={{ color: '#007aff' }} />
            <span>HTML Preview - {getHtmlStyle(selectedHtmlStyle).name}</span>
          </Space>
        }
        open={isHtmlPreviewVisible}
        onCancel={() => setIsHtmlPreviewVisible(false)}
        width="90%"
        style={{ top: 20 }}
        footer={[
          <Button key="export" icon={<ExportOutlined />} onClick={exportToHtml}>
            Export HTML
          </Button>,
          <Button key="close" onClick={() => setIsHtmlPreviewVisible(false)}>
            Close
          </Button>
        ]}
      >
        <div style={{ height: '70vh', overflow: 'auto' }}>
          <iframe
            srcDoc={generateHtmlTemplate(
              isEditing ? editedContent : generatedArticle.preview_html,
              selectedHtmlStyle
            )}
            style={{ width: '100%', height: '100%', border: 'none' }}
          />
        </div>
      </Modal>

      <Modal
        title="Save to Obsidian"
        open={isObsidianModalVisible}
        onCancel={() => setIsObsidianModalVisible(false)}
        onOk={() => obsidianForm.submit()}
        okText="Save"
      >
        <Form
          form={obsidianForm}
          layout="vertical"
          onFinish={handleSaveToObsidian}
          initialValues={{
            folder_name: selectedFolder,
            file_name: generatedArticle ? `${generatedArticle.title}.md` : "Untitled.md",
          }}
        >
          <Form.Item
            name="vault_path"
            label="Obsidian Vault Absolute Path"
            rules={[{ required: true, message: "Please input the vault path!" }]}
          >
            <Input placeholder="/Users/yourname/Documents/Obsidian Vault" />
          </Form.Item>
          <Form.Item
            label="Folder Name"
            required
          >
            <Row gutter={8}>
              <Col flex="auto">
                <Form.Item
                  name="folder_name"
                  noStyle
                  rules={[{ required: true, message: "Please select a folder!" }]}
                >
                  <Input placeholder="Select a folder" readOnly />
                </Form.Item>
              </Col>
              <Col>
                <Button icon={<FolderOpenOutlined />} onClick={handleOpenFolderSelector}>
                  Select
                </Button>
              </Col>
            </Row>
          </Form.Item>
          <Form.Item
            name="file_name"
            label="File Name"
            rules={[{ required: true, message: "Please input the file name!" }]}
          >
            <Input placeholder="My New Article.md" />
          </Form.Item>
        </Form>
      </Modal>

      <Modal
        title="Select Obsidian Folder"
        open={isFolderSelectorVisible}
        onCancel={() => setIsFolderSelectorVisible(false)}
        footer={null}
      >
        {obsidianDirectories.length > 0 ? (
          <Tree.DirectoryTree
            defaultExpandAll
            onSelect={handleSelectFolder}
            treeData={obsidianDirectories}
          />
        ) : (
          <p>No directories found or vault path not set.</p>
        )}
      </Modal>
    </>
  );
};

export default EditableOutput;