import React, { useState, useRef, useCallback } from 'react';
import { Button, Card, Space, Modal, Typography, Row, Col, message, Tabs, Tooltip, Result, Input, Form, Tree } from 'antd';
import { 
  EditOutlined, 
  SaveOutlined, 
  DownloadOutlined, 
  EyeOutlined, 
  FileTextOutlined,
  CodeOutlined,
  BulbOutlined,
  CopyOutlined,
  Html5Outlined,
  ExportOutlined,
  BookOutlined, // For Obsidian
  FolderOpenOutlined // For folder selection
} from '@ant-design/icons';
import { Editor } from '@tinymce/tinymce-react';
import html2canvas from 'html2canvas';
import jsPDF from 'jspdf';
import { getHtmlStyle } from '../utils/htmlStyles';

const { Title, Text } = Typography;

const EditableOutput = ({ generatedArticle, onSave, selectedHtmlStyle = 'modern', embedded = false }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editedContent, setEditedContent] = useState('');
  const [isHtmlPreviewVisible, setIsHtmlPreviewVisible] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
  const [isObsidianModalVisible, setIsObsidianModalVisible] = useState(false);
  const [isFolderSelectorVisible, setIsFolderSelectorVisible] = useState(false);
  const [obsidianDirectories, setObsidianDirectories] = useState([]);
  const [selectedFolder, setSelectedFolder] = useState("Generated Articles");
  const [obsidianForm] = Form.useForm();
  const previewRef = useRef(null);

  const generateHtmlTemplate = useCallback((content, style) => {
    if (!generatedArticle) return '';
    
    const styleConfig = getHtmlStyle(style);
    
    return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${generatedArticle.title}</title>
    <style>
        ${styleConfig.css}
        
        @media (max-width: 768px) {
            .container {
                margin: 0;
                box-shadow: none;
            }
            
            .header, .content {
                padding: 32px 24px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .content {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>${generatedArticle.title}</h1>
            <div class="subtitle">Generated by AI Content Weaver</div>
        </div>
        <div class="content">
            ${content}
        </div>
        <div class="footer">
            <p>Created with AI Content Weaver • ${new Date().toLocaleDateString()}</p>
        </div>
    </div>
</body>
</html>`;
  }, []);

  const handleEdit = () => {
    console.log('handleEdit called, preview_html:', generatedArticle.preview_html);
    
    // Extract only the article content without the template wrapper
    let contentToEdit = generatedArticle.preview_html || '';
    
    // Remove the template wrapper elements if they exist
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = contentToEdit;
    
    // If the content is wrapped in a template structure, extract just the content part
    const container = tempDiv.querySelector('.container .content');
    if (container) {
      contentToEdit = container.innerHTML;
    } else {
      // If no container structure, remove any "Generated by AI Content Weaver" headers
      const headerElements = tempDiv.querySelectorAll('h1, h2, h3, h4, h5, h6, .subtitle, .header');
      headerElements.forEach(element => {
        if (element.textContent.includes('AI Content Weaver') || 
            element.textContent.includes('Generated by')) {
          element.remove();
        }
      });
      contentToEdit = tempDiv.innerHTML;
    }
    
    setEditedContent(contentToEdit);
    setIsEditing(true);
  };

  const handleSave = () => {
    if (onSave) {
      onSave(editedContent);
    }
    setIsEditing(false);
    message.success('Content saved successfully!');
  };

  const handleCancel = () => {
    setIsEditing(false);
    setEditedContent('');
  };

  const handleCopyMarkdown = () => {
    if (generatedArticle && generatedArticle.article_markdown) {
      navigator.clipboard.writeText(generatedArticle.article_markdown)
        .then(() => message.success("Markdown content copied to clipboard!"))
        .catch(err => {
          message.error("Failed to copy Markdown content.");
          console.error('Failed to copy text: ', err);
        });
    }
  };

  // Generate filename with timestamp
  const generateFileName = (extension) => {
    const now = new Date();
    const timestamp = now.getFullYear() +
      String(now.getMonth() + 1).padStart(2, '0') +
      String(now.getDate()).padStart(2, '0') + '_' +
      String(now.getHours()).padStart(2, '0') +
      String(now.getMinutes()).padStart(2, '0') +
      String(now.getSeconds()).padStart(2, '0');
    return `weaved_${timestamp}.${extension}`;
  };

  const exportToHtml = useCallback(() => {
    const content = isEditing ? editedContent : generatedArticle.preview_html;
    const htmlContent = generateHtmlTemplate(content, selectedHtmlStyle);

    const blob = new Blob([htmlContent], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = generateFileName('html');
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    message.success('HTML file downloaded successfully!');
  }, [generatedArticle, isEditing, editedContent, selectedHtmlStyle, generateHtmlTemplate]);

  const exportToPdf = useCallback(async () => {
    if (!previewRef.current) return;
    
    setIsExporting(true);
    try {
      const canvas = await html2canvas(previewRef.current, {
        scale: 2,
        useCORS: true,
        allowTaint: true,
        backgroundColor: '#ffffff'
      });
      
      const imgData = canvas.toDataURL('image/png');
      const pdf = new jsPDF({
        orientation: 'portrait',
        unit: 'mm',
        format: 'a4'
      });
      
      const imgWidth = 210;
      const pageHeight = 295;
      const imgHeight = (canvas.height * imgWidth) / canvas.width;
      let heightLeft = imgHeight;
      
      let position = 0;
      
      pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
      heightLeft -= pageHeight;
      
      while (heightLeft >= 0) {
        position = heightLeft - imgHeight;
        pdf.addPage();
        pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
        heightLeft -= pageHeight;
      }
      
      pdf.save(generateFileName('pdf'));
      message.success('PDF exported successfully!');
    } catch (error) {
      message.error('Failed to export PDF: ' + error.message);
    } finally {
      setIsExporting(false);
    }
  }, [generatedArticle]);

  const handleSaveToObsidian = async (values) => {
    if (!generatedArticle || !generatedArticle.article_markdown) {
      message.error("No content to save.");
      return;
    }

    try {
      const response = await fetch("/api/v1/obsidian/save", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          vault_path: values.vault_path,
          folder_name: values.folder_name,
          file_name: values.file_name,
          content: generatedArticle.article_markdown,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.detail || "Failed to save to Obsidian");
      }

      message.success("Successfully saved to Obsidian!");
      setIsObsidianModalVisible(false);
      obsidianForm.resetFields();
    } catch (error) {
      message.error(error.message);
    }
  };

  const handleOpenFolderSelector = async () => {
    try {
      const vaultPath = await obsidianForm.getFieldValue('vault_path');
      if (!vaultPath) {
        message.error("Please provide the Obsidian vault path first.");
        return;
      }

      const response = await fetch("/api/v1/obsidian/directories", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ vault_path: vaultPath }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.detail || "Failed to fetch directories");
      }

      const data = await response.json();
      setObsidianDirectories(data.directories);
      setIsFolderSelectorVisible(true);
    } catch (error) {
      message.error(`Error fetching directories: ${error.message}`);
    }
  };

  const handleSelectFolder = (selectedKeys) => {
    if (selectedKeys.length > 0) {
      setSelectedFolder(selectedKeys[0]);
      obsidianForm.setFieldsValue({ folder_name: selectedKeys[0] });
      setIsFolderSelectorVisible(false);
    }
  };

  const editorConfig = {
    height: embedded ? 'calc(100vh - 350px)' : 400,
    menubar: false,
    plugins: 'lists link image code table wordcount',
    toolbar: 'undo redo | formatselect | bold italic | alignleft aligncenter alignright | bullist numlist | removeformat | image link | code',
    paste_data_images: true,
    automatic_uploads: true,
    file_picker_types: 'image',
    images_reuse_filename: true,
    convert_urls: false,
    images_upload_handler: (blobInfo, success, failure, progress) => {
      const formData = new FormData();
      formData.append('file', blobInfo.blob(), blobInfo.filename());
      
      return fetch('/api/v1/upload_image', {
        method: 'POST',
        body: formData,
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`Upload failed with status: ${response.status}`);
        }
        return response.json();
      })
      .then(result => {
        // The backend returns the relative path, construct the full URL
        const imageUrl = `/pic/${result.file_path}`;
        success(imageUrl);
        return imageUrl;
      })
      .catch(error => {
        console.error('Image upload error:', error);
        failure('Failed to upload image: ' + error.message);
        throw error;
      });
    },
    content_style: 'body { font-family: -apple-system, BlinkMacSystemFont, San Francisco, Segoe UI, Roboto, Helvetica Neue, sans-serif; font-size: 14px; }'
  };

  if (generatedArticle.status === "error") {
    return (
      <Result
        status="error"
        title={generatedArticle.title}
        subTitle={generatedArticle.subTitle}
        style={{
          background: '#fff',
          borderRadius: 16,
          padding: '48px 24px',
          boxShadow: '0 12px 28px rgba(0,0,0,0.06)'
        }}
      />
    );
  }

  const contentComponent = (
    <div style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
      {/* Action buttons */}
      <div style={{ 
        display: 'flex', 
        justifyContent: 'space-between', 
        alignItems: 'center', 
        marginBottom: '16px',
        padding: embedded ? '0' : '16px 24px',
        borderBottom: embedded ? 'none' : '1px solid var(--theme-border, rgba(0,0,0,0.06))'
      }}>
        {!embedded && (
          <Title level={4} style={{marginBottom: 0, fontWeight: 600}}>
            Generated Article: <Text style={{fontWeight: 400, color: 'rgba(0,0,0,0.6)'}}>{generatedArticle.title}</Text>
          </Title>
        )}
        <Space>
          <Tooltip title="Edit Content">
            <Button
              icon={<EditOutlined />}
              onClick={handleEdit}
              disabled={isEditing}
              shape="round"
            >
              Edit
            </Button>
          </Tooltip>
          <Tooltip title="Export as HTML">
            <Button
              icon={<Html5Outlined />}
              onClick={exportToHtml}
              shape="round"
            >
              HTML
            </Button>
          </Tooltip>
          <Tooltip title="Export as PDF">
            <Button
              icon={<DownloadOutlined />}
              onClick={exportToPdf}
              loading={isExporting}
              shape="round"
            >
              PDF
            </Button>
          </Tooltip>
          <Tooltip title="Preview HTML">
            <Button
              icon={<EyeOutlined />}
              onClick={() => setIsHtmlPreviewVisible(true)}
              shape="round"
            >
              Preview
            </Button>
          </Tooltip>
          <Tooltip title="Save to Obsidian">
            <Button
              icon={<BookOutlined />}
              onClick={() => setIsObsidianModalVisible(true)}
              shape="round"
            >
              Obsidian
            </Button>
          </Tooltip>
        </Space>
      </div>

      {/* Content area */}
      <div style={{ flex: 1, padding: embedded ? '0' : '0 24px 24px 24px' }}>
        {isEditing ? (
          <div style={{ 
            display: 'flex', 
            flexDirection: 'column', 
            height: '100%',
            minHeight: embedded ? 'calc(100vh - 300px)' : '400px'
          }}>
            <div style={{ 
              flex: 1, 
              display: 'flex', 
              flexDirection: 'column',
              minHeight: embedded ? 'calc(100vh - 380px)' : '300px'
            }}>
              <Editor
                tinymceScriptSrc="/tinymce/tinymce.min.js"
                value={editedContent}
                init={editorConfig}
                onEditorChange={(content, editor) => {
                  setEditedContent(content);
                }}
              />
            </div>
            <Row justify="end" style={{ marginTop: 16, flexShrink: 0 }}>
              <Space>
                <Button onClick={handleCancel}>Cancel</Button>
                <Button type="primary" icon={<SaveOutlined />} onClick={handleSave}>
                  Save Changes
                </Button>
              </Space>
            </Row>
          </div>
        ) : (
          <Tabs 
            defaultActiveKey="1" 
            centered 
            type="card" 
            tabBarGutter={8}
            items={[
              {
                key: '1',
                label: <Space><FileTextOutlined/>Preview</Space>,
                children: (
                  <div 
                    ref={previewRef}
                    className="html-preview-box"
                    dangerouslySetInnerHTML={{ __html: generatedArticle.preview_html }} 
                    style={{
                      padding: '24px',
                      border: '1px solid rgba(0,0,0,0.08)',
                      borderRadius: 12,
                      background: '#f8f8f9',
                      height: embedded ? 'calc(100vh - 400px)' : 'calc(100vh - 500px)',
                      lineHeight: 1.6,
                      // CSS 隔离样式，防止生成内容影响网页其他部分
                      contain: 'layout style paint',
                      isolation: 'isolate',
                      overflow: 'auto',
                      overflowWrap: 'break-word',
                      wordBreak: 'break-word',
                      // 重置可能被生成内容影响的样式
                      fontFamily: 'inherit',
                      fontSize: 'inherit',
                      color: 'inherit',
                      // 限制子元素可能的样式溢出
                      position: 'relative',
                      zIndex: 1
                    }}
                  />
                )
              },
              {
                key: '2',
                label: <Space><CodeOutlined/>Markdown</Space>,
                children: (
                  <div style={{padding: '16px', background: '#2d2d2d', borderRadius: 12, height: embedded ? 'calc(100vh - 400px)' : 'calc(100vh - 500px)', overflow: 'auto'}}>
                    <Row justify="end" style={{ marginBottom: 8 }}>
                      <Col>
                        <Button
                          icon={<CopyOutlined />}
                          onClick={handleCopyMarkdown}
                          size="small"
                        >
                          Copy Markdown
                        </Button>
                      </Col>
                    </Row>
                    <pre style={{ margin: 0, color: '#f0f0f0', whiteSpace: 'pre-wrap', wordBreak: 'break-all' }}>
                      <code>{generatedArticle.article_markdown}</code>
                    </pre>
                  </div>
                )
              },
              ...(generatedArticle.suggestions && generatedArticle.suggestions.length > 0 ? [{
                key: '3',
                label: <Space><BulbOutlined/>Suggestions</Space>,
                children: (
                  <div style={{ height: embedded ? 'calc(100vh - 400px)' : 'calc(100vh - 500px)', overflow: 'auto', padding: '16px' }}>
                    <ul style={{ paddingLeft: 20, lineHeight: 1.8 }}>
                      {generatedArticle.suggestions.map((s, i) => <li key={i}><Text>{s}</Text></li>)}
                    </ul>
                  </div>
                )
              }] : [])
            ]}
          />
        )}
      </div>
    </div>
  );

  return (
    <>
      {embedded ? (
        contentComponent
      ) : (
        <Card 
          variant="filled"
          style={{ borderRadius: 16, boxShadow: '0 12px 28px rgba(0,0,0,0.06)', marginTop: 24 }}
          styles={{body: {padding: 0, height: '100%'}}}
        >
          {contentComponent}
        </Card>
      )}

      <Modal
        title={
          <Space>
            <Html5Outlined style={{ color: '#007aff' }} />
            <span>HTML Preview - {getHtmlStyle(selectedHtmlStyle).name}</span>
          </Space>
        }
        open={isHtmlPreviewVisible}
        onCancel={() => setIsHtmlPreviewVisible(false)}
        width="90%"
        style={{ top: 20 }}
        footer={[
          <Button key="export" icon={<ExportOutlined />} onClick={exportToHtml}>
            Export HTML
          </Button>,
          <Button key="close" onClick={() => setIsHtmlPreviewVisible(false)}>
            Close
          </Button>
        ]}
      >
        <div style={{ height: '70vh', overflow: 'auto' }}>
          <iframe
            srcDoc={generateHtmlTemplate(
              isEditing ? editedContent : generatedArticle.preview_html,
              selectedHtmlStyle
            )}
            style={{ width: '100%', height: '100%', border: 'none' }}
          />
        </div>
      </Modal>

      <Modal
        title="Save to Obsidian"
        open={isObsidianModalVisible}
        onCancel={() => setIsObsidianModalVisible(false)}
        onOk={() => obsidianForm.submit()}
        okText="Save"
      >
        <Form
          form={obsidianForm}
          layout="vertical"
          onFinish={handleSaveToObsidian}
          initialValues={{
            folder_name: selectedFolder,
            file_name: generatedArticle ? `${generatedArticle.title}.md` : "Untitled.md",
          }}
        >
          <Form.Item
            name="vault_path"
            label="Obsidian Vault Absolute Path"
            rules={[{ required: true, message: "Please input the vault path!" }]}
          >
            <Input placeholder="/Users/yourname/Documents/Obsidian Vault" />
          </Form.Item>
          <Form.Item
            label="Folder Name"
            required
          >
            <Row gutter={8}>
              <Col flex="auto">
                <Form.Item
                  name="folder_name"
                  noStyle
                  rules={[{ required: true, message: "Please select a folder!" }]}
                >
                  <Input placeholder="Select a folder" readOnly />
                </Form.Item>
              </Col>
              <Col>
                <Button icon={<FolderOpenOutlined />} onClick={handleOpenFolderSelector}>
                  Select
                </Button>
              </Col>
            </Row>
          </Form.Item>
          <Form.Item
            name="file_name"
            label="File Name"
            rules={[{ required: true, message: "Please input the file name!" }]}
          >
            <Input placeholder="My New Article.md" />
          </Form.Item>
        </Form>
      </Modal>

      <Modal
        title="Select Obsidian Folder"
        open={isFolderSelectorVisible}
        onCancel={() => setIsFolderSelectorVisible(false)}
        footer={null}
      >
        {obsidianDirectories.length > 0 ? (
          <Tree.DirectoryTree
            defaultExpandAll
            onSelect={handleSelectFolder}
            treeData={obsidianDirectories}
          />
        ) : (
          <p>No directories found or vault path not set.</p>
        )}
      </Modal>
    </>
  );
};

export default EditableOutput;